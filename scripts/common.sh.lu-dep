#!/usr/bin/env bash

#**************************************************************************************************#
#              OPEN-SOURCE CLOUD INFRASTRUCTURE FOR ENCODING AND DISTRIBUTION : SCRIPTS
#
#  Authors   : David Fischer
#  Contact   : david.fischer.ch@gmail.com / david.fischer@hesge.ch
#  Project   : OSCIED (OS Cloud Infrastructure for Encoding and Distribution)
#  Copyright : 2012 OSCIED Team. All rights reserved.
#**************************************************************************************************#
#
# This file is part of EBU/UER OSCIED Project.
#
# This project is free software: you can redistribute it and/or modify it under the terms of the
# GNU General Public License as published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this project.
# If not, see <http://www.gnu.org/licenses/>
#
# Retrieved from https://github.com/EBU-TI/OSCIED

set -o nounset # will exit if an unitialized variable is used

# Prevent importing N times the following (like C++ .h : #ifndef ... #endif)
if ! osciedCommonImported 2>/dev/null; then

# Constants ========================================================================================

# FIXME Current implementation of orchestra doesn't accept external IP, you must execute
# autodetect-storage-ip.sh to update storage's private IP address automatically
STORAGE_PRIVATE_IP=''
RELEASE='raring'      # Update this according to your needs
NETWORK_IFACE='eth0'  # Update this according to your needs

SCRIPTS_PATH=$(pwd)
BASE_PATH=$(dirname "$SCRIPTS_PATH")
CHARMS_PATH="$BASE_PATH/charms"
CHARMS_DEPLOY_PATH="$CHARMS_PATH/deploy/$RELEASE"
CONFIG_PATH="$BASE_PATH/config"
DOCS_PATH="$BASE_PATH/docs"
MEDIAS_PATH="$BASE_PATH/medias"
SUBLIME_PATH="$BASE_PATH/sublime"
TOOLS_PATH="$BASE_PATH/tools"
REFERENCES_PATH="$DOCS_PATH/references"

# Reports related configuration (e.g. listing of components)
REPORT_TOOLS_PLANTUML_BINARY="$TOOLS_PATH/plantuml.jar"
DAVID_REPORT_RELEASE_PATH="$DOCS_PATH/david/master_thesis"
DAVID_REPORT_PATH="$DOCS_PATH/david/master_thesis_rst"
DAVID_REPORT_BUILD_PATH="$DAVID_REPORT_PATH/build"
DAVID_REPORT_UML_PATH="$DAVID_REPORT_PATH/uml"
DAVID_REPORT_COMPONENTS_FILE="$DAVID_REPORT_PATH/source/components.csv"

# # Generated configuration
CONFIG_GEN_PATH="$CONFIG_PATH/generated"
CONFIG_GEN_AUTHS_FILE="$CONFIG_GEN_PATH/auths.list"
CONFIG_GEN_IDS_FILE="$CONFIG_GEN_PATH/ids.list"
CONFIG_GEN_JSON_FILE="$CONFIG_GEN_PATH/json.list"
CONFIG_GEN_UNITS_FILE="$CONFIG_GEN_PATH/units.list"
CONFIG_GEN_CONFIG_FILE="$CONFIG_GEN_PATH/config.yaml"

# # Orchestra related configuration (e.g. initial setup)
CONFIG_API_PATH="$CONFIG_PATH/api"
CONFIG_API_USERS_FILE="$CONFIG_API_PATH/users.csv"
CONFIG_API_MEDIAS_FILE="$CONFIG_API_PATH/medias.csv"
CONFIG_API_TPROFILES_FILE="$CONFIG_API_PATH/tprofiles.csv"

# # JuJu related configuration (e.g. environments)
CONFIG_JUJU_PATH="$CONFIG_PATH/juju"
CONFIG_JUJU_ID_RSA="$CONFIG_JUJU_PATH/id_rsa"
CONFIG_JUJU_ID_RSA_PUB="$CONFIG_JUJU_PATH/id_rsa.pub"
CONFIG_JUJU_ENVS_FILE="$CONFIG_JUJU_PATH/environments.yaml"
CONFIG_JUJU_FILES_PATH="$CONFIG_PATH/juju_files"
CONFIG_JUJU_TEMPL_FILE="$CONFIG_JUJU_FILES_PATH/environments.yaml.template"

CONFIG_SCENARIOS_PATH="$CONFIG_PATH/scenarios"

JUJU_PATH="$HOME/.juju"
JUJU_STORAGE_PATH="$JUJU_PATH/storage/"
JUJU_ENVS_FILE="$JUJU_PATH/environments.yaml"

BAD_AUTH='charlie@hacker.com:challenge_accepted'

# Utilities ========================================================================================

# Parse config.json of a actually running charm instance ! -----------------------------------------

get_unit_config()
{
  if [ $# -ne 3 ]; then
    xecho "Usage: $(basename $0).get_config_unit name number option"
  fi
  name=$1
  number=$2
  option=$3
  val=$(juju ssh $name/$number "cat /var/lib/juju/units/$name-*/charm/config.json")
  REPLY=$(expr match "$val" ".*\"$option\": \"\([^\"]*\)\",.*")
}

# Parse orchestra.yaml configuration file to get options value -------------------------------------

get_root_secret()
{
  if [ -f "$CONFIG_GEN_CONFIG_FILE" ]; then
    line=$(cat "$CONFIG_GEN_CONFIG_FILE" | grep root_secret)
    root=$(expr match "$line" '.*"\(.*\)".*')
  else
    root='toto'
  fi
  [ ! "$root" ] && xecho 'Unable to detect root secret !'
  REPLY="$root"
}

get_node_secret()
{
  if [ -f "$CONFIG_GEN_CONFIG_FILE" ]; then
    line=$(cat "$CONFIG_GEN_CONFIG_FILE" | grep nodes_secret)
    node=$(expr match "$line" '.*"\(.*\)".*')
  else
    node='abcd'
  fi
  [ ! "$node" ] && xecho 'Unable to detect nodes secret !'
  REPLY="$node"
}

# Parse charm's units URLs listing file to get specific URLs ---------------------------------------

get_units_dialog_listing()
{
  REPLY=$(cat "$CONFIG_GEN_UNITS_FILE" | sort | sed 's:=: :g;s:\n: :g')
  [ ! $REPLY ] && xecho 'Unable to generate units listing for dialog'
}

get_services_dialog_listing()
{
  REPLY=$(cat "$CONFIG_GEN_UNITS_FILE" | sort | sed 's:/[0-9]*=: :g;s:\n: :g' | uniq)
  [ ! $REPLY ] && xecho 'Unable to generate services listing for dialog'
}

get_unit_public_url()
{
  if [ $# -gt 2 ]; then
    xecho "Usage: $(basename $0).get_unit_public_url name (number)"
  fi
  name=$1
  [ $# -eq 2 ] && number=$2 || number='.*'
  if [ -f "$CONFIG_GEN_UNITS_FILE" ]; then
    url=$(cat "$CONFIG_GEN_UNITS_FILE" | grep -m 1 "^$name/$number=" | cut -d '=' -f2)
  else
    url='127.0.0.1'
  fi
  [ ! "$url" ] && xecho "Unable to detect unit $1 public URL !"
  REPLY="$url"
}

get_orchestra_url()
{
  if [ $# -eq 0 ]; then
    get_unit_public_url 'oscied-orchestra'
  elif [ $# -eq 1 ]; then
    get_unit_public_url 'oscied-orchestra' "$1"
  else
    xecho "Usage: $(basename $0).get_orchestra_url (number)"
  fi
  REPLY="http://$REPLY:5000"
}

get_storage_uploads_url()
{
  REPLY="glusterfs://$STORAGE_PRIVATE_IP/medias_volume/uploads"

}

get_storage_medias_url()
{
  REPLY="glusterfs://$STORAGE_PRIVATE_IP/medias_volume/medias"
}

storage_upload_media()
{
  if [ $# -ne 1 ]; then
    xecho "Usage: $(basename $0).storage_upload_media filename"
  fi

  get_unit_public_url 'oscied-storage'
  host="ubuntu@$REPLY"
  bkp_path='/home/ubuntu/uploads'
  dst_path="/exp1/uploads"
  certif="$CONFIG_JUJU_ID_RSA"
  chmod 600 "$certif" || xecho 'Unable to find id_rsa certificate'
  rsync -ah --progress --rsync-path='sudo rsync' -e "ssh -i '$certif'" "$1" "$host:$bkp_path/" || \
    xecho "Unable to copy media file to $bkp_path path in storage"
  ssh -i "$certif" "$host" -n "sudo rsync -ah --progress $bkp_path/ $dst_path/" || \
    xecho "Unable to synchronize ($dst_path->$dst_path) paths in storage"
  ssh -i "$certif" "$host" -n "sudo chown www-data:www-data $dst_path/ -R" || \
    xecho "Unable to set owner www-data for $dst_path path in storage"
  get_storage_uploads_url
  REPLY="$REPLY/$(basename $1)"
}

# Wrapper to juju ----------------------------------------------------------------------------------

juju_unit_add()
{
  if [ $# -ne 1 ]; then
    xecho "Usage: $(basename $0).juju_unit_add service"
  fi
  juju add-unit "$1"
}

juju_unit_remove()
{
  if [ $# -ne 1 ]; then
    xecho "Usage: $(basename $0).juju_unit_remove unit"
  fi
  if juju remove-unit "$1"; then
    cat "$CONFIG_GEN_UNITS_FILE" | grep -v "$1=.*" > $tmpfile
    mv $tmpfile "$CONFIG_GEN_UNITS_FILE"
  fi
}

# Save and get configuration from corresponding generated files ------------------------------------

save_auth()
{
  cat "$CONFIG_GEN_AUTHS_FILE" 2>/dev/null | grep -v "^$1=" > /tmp/$$
  echo "$1=$2" >> /tmp/$$
  mv /tmp/$$ "$CONFIG_GEN_AUTHS_FILE"
}

get_auth()
{
  REPLY=$(cat "$CONFIG_GEN_AUTHS_FILE" 2>/dev/null | grep "^$1=" | cut -d '=' -f2)
  [ ! "$REPLY" ] && xecho "Unable to detect $1 authentication"
}

save_id()
{
  cat "$CONFIG_GEN_IDS_FILE" 2>/dev/null | grep -v "^$1=" > /tmp/$$
  echo "$1=$2" >> /tmp/$$
  mv /tmp/$$ "$CONFIG_GEN_IDS_FILE"
}

get_id()
{
  REPLY=$(cat "$CONFIG_GEN_IDS_FILE" 2>/dev/null | grep "^$1=" | cut -d '=' -f2)
  [ ! "$REPLY" ] && xecho "Unable to detect $1 ID"
}

save_json()
{
  cat "$CONFIG_GEN_JSON_FILE" 2>/dev/null | grep -v "^$1=" > /tmp/$$
  echo "$1=$2" >> /tmp/$$
  mv /tmp/$$ "$CONFIG_GEN_JSON_FILE"
}

get_json()
{
  REPLY=$(cat "$CONFIG_GEN_JSON_FILE" 2>/dev/null | grep "^$1=" | cut -d '=' -f2)
  [ ! "$REPLY" ] && xecho "Unable to detect $1 json"
}

# Generate valid json strings of Orchestra API's objects -------------------------------------------

json_user()
{
  if [ $# -ne 5 ]; then
    xecho "Usage: $(basename $0).json_user fname lname mail secret aplaftorm"
  fi

  a='admin_platform'
  JSON="{\"first_name\":\"$1\",\"last_name\":\"$2\",\"mail\":\"$3\",\"secret\":\"$4\",\"$a\":$5}"
}

json_media()
{
  if [ $# -ne 3 ]; then
    xecho "Usage: $(basename $0).json_media uri vfilename title"
  fi

  JSON="{\"uri\":\"$1\",\"virtual_filename\":\"$2\",\"metadata\":{\"title\":\"$3\"}}"
}

json_tprofile()
{
  if [ $# -ne 3 ]; then
    xecho "Usage: $(basename $0).json_tprofile title description encoder_string"
  fi

  JSON="{\"title\":\"$1\",\"description\":\"$2\",\"encoder_string\":\"$3\"}"
}

json_tjob()
{
  d='metadata'
  m='media_in_id'
  p='profile_id'
  q='queue'
  t='title'
  v='virtual_filename'
  y='priority'
  if [ $# -ne 6 ]; then
    xecho "Usage: $(basename $0).json_tjob $m $p $v $t $q $y"
  fi

  JSON="{\"$m\":\"$1\",\"$p\":\"$2\",\"$v\":\"$3\",\"$d\":{\"$t\":\"$4\"},\"$q\":\"$5\",\"$y\":\"$6\"}"
}

json_pjob()
{
  if [ $# -ne 3 ]; then
    xecho "Usage: $(basename $0).json_tjob media_id queue priority"
  fi

  JSON="{\"media_id\":\"$1\",\"queue\":\"$2\",\"priority\":\"$3\"}"
}

# Used to call / test Orchestra REST API -----------------------------------------------------------

test_api()
{
  if [ $# -ne 5 ]; then
    xecho "Usage: $(basename $0).test_api code method call user data"
  fi

  code=$1; m=$2; c=$3; u=$4; d=$5
  aa='Accept: application/json'
  ct='Content-type: application/json'
  if [ "$u" -a "$d" ]; then
    mecho "\nTest $code : $m $c auth: $u data: $d"
    result=$(curl -H "$aa" -H "$ct" -u "$u" -d "$d" -X "$m" "$c" --write-out %{http_code})
  elif [ "$u" ]; then
    mecho "\nTest $code : $m $c auth: $u"
    result=$(curl -H "$aa" -H "$ct" -u "$u" -X "$m" "$c" --write-out %{http_code})
  elif [ "$d" ]; then
    mecho "\nTest $code : $m $c data: $d"
    result=$(curl -H "$aa" -H "$ct" -d "$d" -X "$m" "$c" --write-out %{http_code})
  else
    mecho "\nTest $code : $m $c"
    result=$(curl -H "$aa" -H "$ct" -X "$m" "$c" --write-out %{http_code})
  fi
  echo $result
  if ! echo "$result" | grep -q "$code\$"; then
    xecho "Test $m $c failed with code : $result"
  fi
  echo
  anum='0-9a-zA-Z'
  regex=".*\"\([$anum]\{8\}-[$anum]\{4\}-[$anum]\{4\}-[$anum]\{4\}-[$anum]\{12\}\)\".*"
  ID=$(expr match "$result" "$regex")
}

osciedCommonImported()
{
  echo > /dev/null
}
fi
