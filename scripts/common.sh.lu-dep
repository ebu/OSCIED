#!/usr/bin/env bash

#**********************************************************************************************************************#
#              OPEN-SOURCE CLOUD INFRASTRUCTURE FOR ENCODING AND DISTRIBUTION : SCRIPTS
#
#  Authors   : David Fischer
#  Contact   : david.fischer.ch@gmail.com
#  Project   : OSCIED (OS Cloud Infrastructure for Encoding and Distribution)
#  Copyright : 2012-2013 OSCIED Team. All rights reserved.
#**********************************************************************************************************************#
#
# This file is part of EBU/UER OSCIED Project.
#
# This project is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# This project is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this project.
# If not, see <http://www.gnu.org/licenses/>
#
# Retrieved from https://github.com/ebu/OSCIED

set -o nounset # will exit if an unitialized variable is used

# Prevent importing N times the following (like C++ .h : #ifndef ... #endif)
if ! osciedCommonImported 2>/dev/null; then

# Constants ============================================================================================================

RELEASE='raring'      # Update this according to your needs
NETWORK_IFACE='eth0'  # Update this according to your needs

SCRIPTS_PATH=$(pwd)
BASE_PATH=$(dirname "$SCRIPTS_PATH")
CHARMS_PATH="$BASE_PATH/charms"
CHARMS_DEPLOY_PATH="$BASE_PATH/deploy/$RELEASE"
DOCS_PATH="$BASE_PATH/docs"
LIBRARY_PATH="$BASE_PATH/library"
MEDIAS_PATH="$BASE_PATH/medias"
SCENARIOS_PATH="$BASE_PATH/scenarios"
TEMPLATES_PATH="$BASE_PATH/templates"
TOOLS_PATH="$BASE_PATH/tools"
REFERENCES_PATH="$DOCS_PATH/references"

# Symbolic link to current configuration's path
SCENARIO_CURRENT_PATH="$SCENARIOS_PATH/current"

# Generated configuration
SCENARIO_GEN_PATH="$SCENARIO_CURRENT_PATH/generated"
SCENARIO_GEN_AUTHS_FILE="$SCENARIO_GEN_PATH/auths.list"
SCENARIO_GEN_IDS_FILE="$SCENARIO_GEN_PATH/ids.list"
SCENARIO_GEN_JSON_FILE="$SCENARIO_GEN_PATH/json.list"
SCENARIO_GEN_UNITS_FILE="$SCENARIO_GEN_PATH/units.list"
SCENARIO_GEN_STORAGE_FILE="$SCENARIO_GEN_PATH/storage.inc"

# Orchestra related configuration (e.g. initial setup)
SCENARIO_API_USERS_FILE="$SCENARIO_CURRENT_PATH/users.csv"
SCENARIO_API_MEDIAS_FILE="$SCENARIO_CURRENT_PATH/medias.csv"
SCENARIO_API_TPROFILES_FILE="$SCENARIO_CURRENT_PATH/tprofiles.csv"

# JuJu related configuration (e.g. environments)
SCENARIO_JUJU_ID_RSA="$SCENARIO_CURRENT_PATH/id_rsa"
SCENARIO_JUJU_ID_RSA_PUB="$SCENARIO_CURRENT_PATH/id_rsa.pub"
SCENARIO_JUJU_ENVS_FILE="$SCENARIO_CURRENT_PATH/environments.yaml"

# System configuration (e.g. certificates + juju configuration)
ID_RSA="$HOME/.ssh/id_rsa"
ID_RSA_PUB="$HOME/.ssh/id_rsa.pub"
JUJU_LOG="$BASE_PATH/juju-debug.log"
JUJU_PATH="$HOME/.juju"
JUJU_STORAGE_PATH="$JUJU_PATH/local/"
JUJU_ENVS_FILE="$JUJU_PATH/environments.yaml"


# Utilities ============================================================================================================

_reload_config()
{
  STORAGE_PRIVATE_IP=''
  STORAGE_MOUNTPOINT=''
  STORAGE_BRICK=''  
  if [ -f "$SCENARIO_GEN_STORAGE_FILE" ]; then
    . "$SCENARIO_GEN_STORAGE_FILE"
  fi
}

_check_config()
{
  _reload_config
  if [ "$STORAGE_PRIVATE_IP" -a "$STORAGE_MOUNTPOINT" -a "$STORAGE_BRICK" ]; then
    echo ''
  elif [ $# -gt 0 ]; then
    echo '[DISABLED] '
  else
    xecho 'You must execute menu.sh config first'
  fi
}

_check_juju()
{
  if which juju > /dev/null; then
    echo ''
  elif [ $# -gt 0 ]; then
    echo '[DISABLED] '
  else
    xecho 'JuJu must be installed, this method is disabled'
  fi
}

_deploy_helper()
{
  if [ $# -ne 1 ]; then
    xecho "Usage: $(basename $0).overwrite_helper scenario"
  fi
  scenario=$1

  techo "Deploy scenario $scenario"

  pecho 'Update symlink to current scenario'
  rm -f "$SCENARIO_CURRENT_PATH" 2>/dev/null
  ln -s "$scenario" "$SCENARIO_CURRENT_PATH" || xecho 'Unable to update symlink'

  pecho 'Initialize JuJu orchestrator configuration'
  if [ -f "$ID_RSA" ]; then
    suffix=$(md5sum "$ID_RSA" | cut -d' ' -f1)
    mecho "Backup certificate $ID_RSA into ${ID_RSA}_$suffix"
    cp -f "$ID_RSA"     "${ID_RSA}_$suffix"     || xecho 'Unable to backup certificate file (1/2)'
    cp -f "$ID_RSA_PUB" "${ID_RSA_PUB}_$suffix" || xecho 'Unable to backup certificate file (2/2)'
  fi
  if [ ! -f "$SCENARIO_JUJU_ID_RSA" ]; then
    recho 'It is strongly advised to create a certificate per scenario'
    yesOrNo $default 'generate it now'
    if [ $REPLY -eq $true ]; then
      ssh-keygen -t rsa -b 2048 -f "$SCENARIO_JUJU_ID_RSA"
    fi
  fi
  if [ -f "$SCENARIO_JUJU_ID_RSA" ]; then
    mecho "Using scenario's certificate file : $SCENARIO_JUJU_ID_RSA"
    # And make scenario's certificate the default
    cp -f "$SCENARIO_JUJU_ID_RSA"     "$ID_RSA"     || xecho 'Unable to copy certificate file (1/2)'
    cp -f "$SCENARIO_JUJU_ID_RSA_PUB" "$ID_RSA_PUB" || xecho 'Unable to copy certificate file (2/2)'
  fi
  # Fix ERROR SSH forwarding error: Agent admitted failure to sign using the key.
  ssh-add "$ID_RSA"

  # FIXME and what about *.pem stuff ?

  mkdir -p "$JUJU_PATH" "$JUJU_STORAGE_PATH" 2>/dev/null
  # Backup any already existing environments file (magic stuff) !
  if [ -f "$JUJU_ENVS_FILE" ]; then
    suffix=$(md5sum "$JUJU_ENVS_FILE" | cut -d' ' -f1)
    cp -f "$JUJU_ENVS_FILE" "${JUJU_ENVS_FILE}_$suffix" || xecho 'Unable to backup environments file'
  fi
  if [ -f "$SCENARIO_JUJU_ENVS_FILE" ]; then
    mecho "Using scenario's environments file : $SCENARIO_JUJU_ENVS_FILE"
    cp "$SCENARIO_JUJU_ENVS_FILE" "$JUJU_ENVS_FILE" || xecho 'Unable to copy environments file'
  else
    mecho 'Using juju to generate default environments file'
    juju generate-config -w || xecho "Unable to generate juju's environments file"
  fi
  $udo ufw disable # Fix master thesis ticket #80 - Juju stuck in pending when using LXC

  pecho "Copy JuJu environments file & SSH keys to Orchestra charm's deployment path"
  cp -f "$ID_RSA"         "$CHARMS_DEPLOY_PATH/oscied-orchestra/ssh/"
  cp -f "$ID_RSA_PUB"     "$CHARMS_DEPLOY_PATH/oscied-orchestra/ssh/"
  cp -f "$JUJU_ENVS_FILE" "$CHARMS_DEPLOY_PATH/oscied-orchestra/juju/"
  find "$JUJU_PATH" -mindepth 1 -maxdepth 1 -type f -name '*.pem' -exec cp -f {} \
    "$CHARMS_DEPLOY_PATH/oscied-orchestra/juju/" \;

  pecho "Execute script of scenario $scenario"
  $udo python "$scenario/scenario.py" "$(dirname "$CHARMS_DEPLOY_PATH")" -r "$RELEASE"
}

_overwrite_helper()
{
  if [ $# -ne 2 ]; then
    xecho "Usage: $(basename $0).overwrite_helper source destination"
  fi

  mkdir -p "$CHARMS_DEPLOY_PATH/$2" 2>/dev/null
  rsync -rtvh -LH --delete --progress --exclude='.git' --exclude='*.log' --exclude='*.pyc' \
    --exclude='celeryconfig.py' --exclude='build' --exclude='dist' --exclude='*.egg-info' \
    "$CHARMS_PATH/$1/" "$CHARMS_DEPLOY_PATH/$2/" || xecho "Unable to overwrite $2 charm"
}

_rsync_helper()
{
  if [ $# -ne 2 ]; then
    xecho "Usage: $(basename $0).rsync_publisher charm id"
  fi

  chmod 600 "$ID_RSA" || xecho 'Unable to find id_rsa certificate'

  _get_unit_public_url $true "$1" "$2"
  host="ubuntu@$REPLY"
  dest="/var/lib/juju/agents/unit-$1-$2/charm"
  ssh -i "$ID_RSA" "$host" -n "sudo chown 1000:1000 $dest -R"
  rsync -avhL --progress --delete -e "ssh -i '$ID_RSA'" --exclude=.git --exclude=config.json \
    --exclude=celeryconfig.py --exclude=*.pyc --exclude=local_config.pkl --exclude=charms \
    --exclude=ssh --exclude=environments.yaml --exclude=*.log "$CHARMS_PATH/$1/" "$host:$dest/"
  ssh -i "$ID_RSA" "$host" -n "sudo chown root:root $dest -R"
}

_standalone_execute_hook()
{
  if [ $# -ne 2 ]; then
    xecho "Usage: $(basename $0).standalone_execute_hook path hook"
  fi

  pecho 'Install juju-log & open-port tricks'
  if ! getInterfaceIPv4 "$NETWORK_IFACE" '4'; then
    xecho "Unable to detect network interface $NETWORK_IFACE IP address"
  fi
  ip=$REPLY
  $udo sh -c "cp -f $TEMPLATES_PATH/juju-log      $jujulog;  chmod 777 $jujulog"
  $udo sh -c "cp -f $TEMPLATES_PATH/open-port     $openport; chmod 777 $openport"
  $udo sh -c "cp -f $TEMPLATES_PATH/something-get $cget;     chmod 777 $cget"
  $udo sh -c "cp -f $TEMPLATES_PATH/something-get $rget;     chmod 777 $rget"
  $udo sh -c "cp -f $TEMPLATES_PATH/something-get $uget;     chmod 777 $uget"
  $udo sh -c "cp -f $TEMPLATES_PATH/something-get.list /tmp/;"
  $udo sh -c "sed -i 's:127.0.0.1:$ip:g' /tmp/something-get.list"
  pecho "Execute hook script $2"
  cd "$1"  || xecho "Unable to find path $1"
  $udo $2  || xecho 'Hook is unsucessful'
  recho 'Hook successful'
}

# Parse local_config.pkl of a actually running charm instance ! --------------------------------------------------------

_get_unit_config()
{
  if [ $# -ne 3 ]; then
    xecho "Usage: $(basename $0).get_config_unit name number option"
  fi
  name=$1
  number=$2
  option=$3

  # Example : sS'storage_address' p29 S'ip-10-245-189-174.ec2.internal' p30
  chmod1="sudo chmod +rx /var/lib/juju/agents/unit-$name-$number/"
  chmod2="sudo chmod +rx /var/lib/juju/agents/unit-$name-$number/charm/"
  chmod3="sudo chmod +rx /var/lib/juju/agents/unit-$name-$number/charm/local_config.pkl"
  cat_local_config="/var/lib/juju/agents/unit-$name-$number/charm/local_config.pkl"
  val=$(juju ssh $name/$number "$chmod1; $chmod2; $chmod3; tr '\n' ' ' < $cat_local_config")
  REPLY=$(expr match "$val" ".*S'$option' p[0-9]\+ .'*\([^ ']*\)")
}

# Parse charm's units URLs listing file to get specific URLs -----------------------------------------------------------

_get_units_dialog_listing()
{
  REPLY=$(cat "$SCENARIO_GEN_UNITS_FILE" | sort | sed 's:=: :g;s:\n: :g')
  [ ! $REPLY ] && xecho 'Unable to generate units listing for dialog'
}

_get_services_dialog_listing()
{
  REPLY=$(cat "$SCENARIO_GEN_UNITS_FILE" | sort | sed 's:/[0-9]*=: :g;s:\n: :g' | uniq)
  [ ! $REPLY ] && xecho 'Unable to generate services listing for dialog'
}

_get_unit_public_url()
{
  if [ $# -gt 3 ]; then
    xecho "Usage: $(basename $0).get_unit_public_url fail name (number)"
  fi
  fail=$1
  name=$2

  [ $# -eq 3 ] && number=$3 || number='.*'
  if [ -f "$SCENARIO_GEN_UNITS_FILE" ]; then
    url=$(cat "$SCENARIO_GEN_UNITS_FILE" | grep -m 1 "^$name/$number=" | cut -d '=' -f2)
  else
    url='127.0.0.1'
  fi
  [ ! "$url" -a $fail -eq $true ] && xecho "Unable to detect unit $1 public URL !"
  REPLY="$url"
}

_get_orchestra_url()
{
  if [ $# -eq 0 ]; then
    _get_unit_public_url $false 'oscied-orchestra'
  elif [ $# -eq 1 ]; then
    _get_unit_public_url $false 'oscied-orchestra' "$1"
  else
    xecho "Usage: $(basename $0).get_orchestra_url (number)"
  fi
  [ "$REPLY" ] && REPLY="http://$REPLY:5000"
}

_get_storage_uploads_url()
{
  REPLY="glusterfs://$STORAGE_PRIVATE_IP/$STORAGE_MOUNTPOINT/uploads"

}

_get_storage_medias_url()
{
  REPLY="glusterfs://$STORAGE_PRIVATE_IP/$STORAGE_MOUNTPOINT/medias"
}

_storage_upload_media()
{
  if [ $# -ne 1 ]; then
    xecho "Usage: $(basename $0).storage_upload_media filename"
  fi

  _get_unit_public_url $true 'oscied-storage'
  host="ubuntu@$REPLY"
  bkp_path='/home/ubuntu/uploads'
  dst_path="$STORAGE_BRICK/uploads"
  chmod 600 "$ID_RSA" || xecho 'Unable to find id_rsa certificate'
  rsync -ah --progress --rsync-path='sudo rsync' -e "ssh -i '$ID_RSA'" "$1" "$host:$bkp_path/" || \
    xecho "Unable to copy media file to $bkp_path path in storage"
  ssh -i "$ID_RSA" "$host" -n "sudo rsync -ah --progress $bkp_path/ $dst_path/" || \
    xecho "Unable to synchronize ($dst_path->$dst_path) paths in storage"
  ssh -i "$ID_RSA" "$host" -n "sudo chown www-data:www-data $dst_path/ -R" || \
    xecho "Unable to set owner www-data for $dst_path path in storage"
  _get_storage_uploads_url
  REPLY="$REPLY/$(basename $1)"
}

# Save and get configuration from corresponding generated files --------------------------------------------------------

_save_auth()
{
  cat "$SCENARIO_GEN_AUTHS_FILE" 2>/dev/null | grep -v "^$1=" > /tmp/$$
  echo "$1=$2" >> /tmp/$$
  mv /tmp/$$ "$SCENARIO_GEN_AUTHS_FILE"
}

_get_auth()
{
  REPLY=$(cat "$SCENARIO_GEN_AUTHS_FILE" 2>/dev/null | grep "^$1=" | cut -d '=' -f2)
  [ ! "$REPLY" ] && xecho "Unable to detect $1 authentication"
}

_save_id()
{
  cat "$SCENARIO_GEN_IDS_FILE" 2>/dev/null | grep -v "^$1=" > /tmp/$$
  echo "$1=$2" >> /tmp/$$
  mv /tmp/$$ "$SCENARIO_GEN_IDS_FILE"
}

_get_id()
{
  REPLY=$(cat "$SCENARIO_GEN_IDS_FILE" 2>/dev/null | grep "^$1=" | cut -d '=' -f2)
  [ ! "$REPLY" ] && xecho "Unable to detect $1 ID"
}

_save_json()
{
  cat "$SCENARIO_GEN_JSON_FILE" 2>/dev/null | grep -v "^$1=" > /tmp/$$
  echo "$1=$2" >> /tmp/$$
  mv /tmp/$$ "$SCENARIO_GEN_JSON_FILE"
}

_get_json()
{
  REPLY=$(cat "$SCENARIO_GEN_JSON_FILE" 2>/dev/null | grep "^$1=" | cut -d '=' -f2)
  [ ! "$REPLY" ] && xecho "Unable to detect $1 json"
}

# Generate valid json strings of Orchestra API's objects ---------------------------------------------------------------

_json_user()
{
  if [ $# -ne 5 ]; then
    xecho "Usage: $(basename $0).json_user fname lname mail secret aplaftorm"
  fi

  a='admin_platform'
  JSON="{\"first_name\":\"$1\",\"last_name\":\"$2\",\"mail\":\"$3\",\"secret\":\"$4\",\"$a\":$5}"
}

_json_media()
{
  if [ $# -ne 3 ]; then
    xecho "Usage: $(basename $0).json_media uri vfilename title"
  fi

  JSON="{\"uri\":\"$1\",\"filename\":\"$2\",\"metadata\":{\"title\":\"$3\"}}"
}

_json_tprofile()
{
  if [ $# -ne 4 ]; then
    xecho "Usage: $(basename $0).json_tprofile title description encoder_name encoder_string"
  fi

  JSON="{\"title\":\"$1\",\"description\":\"$2\",\"encoder_name\":\"$3\",\"encoder_string\":\"$4\"}"
}

_json_ttask()
{
  d='metadata'
  m='media_in_id'
  p='profile_id'
  q='queue'
  t='title'
  v='filename'
  y='priority'
  if [ $# -ne 6 ]; then
    xecho "Usage: $(basename $0).json_ttask $m $p $v $t $q $y"
  fi

  JSON="{\"$m\":\"$1\",\"$p\":\"$2\",\"$v\":\"$3\",\"$d\":{\"$t\":\"$4\"},\"$q\":\"$5\",\"$y\":\"$6\"}"
}

_json_ptask()
{
  if [ $# -ne 3 ]; then
    xecho "Usage: $(basename $0).json_ttask media_id queue priority"
  fi

  JSON="{\"media_id\":\"$1\",\"queue\":\"$2\",\"priority\":\"$3\"}"
}

# Used to call / test Orchestra REST API -------------------------------------------------------------------------------

_test_api()
{
  if [ $# -ne 5 ]; then
    xecho "Usage: $(basename $0).test_api code method call user data"
  fi

  code=$1; m=$2; c=$3; u=$4; d=$5
  aa='Accept: application/json'
  ct='Content-type: application/json'
  if [ "$u" -a "$d" ]; then
    mecho "\nTest $code : $m $c auth: $u data: $d"
    result=$(curl -H "$aa" -H "$ct" -u "$u" -d "$d" -X "$m" "$c" --write-out %{http_code})
  elif [ "$u" ]; then
    mecho "\nTest $code : $m $c auth: $u"
    result=$(curl -H "$aa" -H "$ct" -u "$u" -X "$m" "$c" --write-out %{http_code})
  elif [ "$d" ]; then
    mecho "\nTest $code : $m $c data: $d"
    result=$(curl -H "$aa" -H "$ct" -d "$d" -X "$m" "$c" --write-out %{http_code})
  else
    mecho "\nTest $code : $m $c"
    result=$(curl -H "$aa" -H "$ct" -X "$m" "$c" --write-out %{http_code})
  fi
  echo $result
  if ! echo "$result" | grep -q "$code\$"; then
    xecho "Test $m $c failed with code : $result"
  fi
  echo
  anum='0-9a-zA-Z'
  regex=".*\"\([$anum]\{8\}-[$anum]\{4\}-[$anum]\{4\}-[$anum]\{4\}-[$anum]\{12\}\)\".*"
  ID=$(expr match "$result" "$regex")
}

osciedCommonImported()
{
  echo > /dev/null
}
fi
